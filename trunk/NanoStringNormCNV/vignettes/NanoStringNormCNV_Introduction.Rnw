%\VignetteIndexEntry{Introduction to NanoStringNormCNV}
%\VignetteDepends{vsn,googleVis,gdata}
%\VignetteKeywords{CNV Analysis}
%\VignettePackage{NanoStringNormCNV}

%------------------------------------------------------------
% setup document
%------------------------------------------------------------

\documentclass{article}
\usepackage[margin=2cm,nohead]{geometry}
\usepackage{color}
\usepackage{cite}
\usepackage{flafter}
\usepackage{afterpage}
\usepackage{caption}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\definecolor{ns.green}{rgb}{0.0,0.0,0.75}
\definecolor{ns.orange}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://cran.r-project.org/},%
pdftitle={Introduction to analyzing NanoString nCounter data using the NanoStringNormCNV package},%
pdfauthor={Dorota Sendorek},%
pdfsubject={NanoStringNormCNV},%
pdfkeywords={NanoString},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

\SweaveOpts{keep.source=TRUE,eps=FALSE,include=FALSE,width=5,height=5} 

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

%------------------------------------------------------------
% start document
%------------------------------------------------------------

\begin{document}
%----------------------------------------------------------------------------------------
\title{Introduction to analyzing NanoString nCounter data using the NanoStringNormCNV package}
\author{Dorota Sendorek}
%----------------------------------------------------------------------------------------
\maketitle
\tableofcontents
%\listoffigures
\clearpage
%------------------------------------------------------------
% set R defaults
%------------------------------------------------------------

<<setup, echo=FALSE,results=hide>>=
options(width=100, signif=3, digits=3)
set.seed(0xdada)

## To create bitmap versions of plots with many dots, circumventing
##   Sweave's fig=TRUE mechanism...
##   (pdfs are too large)
openBitmap = function(nm, rows=1, cols=1) {
  png(paste("NSN-", nm, ".png", sep=""), 
       width=600*cols, height=700*rows, pointsize=14)
  par(mfrow=c(rows, cols), cex=2)
}
@

%------------------------------------------------------------
\section{Getting started}\label{sec:started}
%------------------------------------------------------------ 
NanoStringNormCNV is a suite of tools used to perform quality control, pre-processing, copy number calling and visualization on NanoString nCounter DNA data. NanoString is a medium-throughput platform which first gained popularity through gene expression quantification and, now, has extended its functionality to CNV detection in genomic DNA. NanoString holds a number of advantages over traditional assays and these include its ability to handle lower quality samples, measure DNA without necessary amplification, and produce an absolute nucleic acid count. Given this, the applications of this technology are wide-ranging, from validation to clinical.
\\ \\
NanoStringNormCNV has been created to aid the user in identifying the optimal data analysis techniques for their dataset, as well as providing a NanoString CNV analysis foundation for the community to build on. Additionally, NanoStringNormCNV is an extension of the NanoStringNorm package, enabling the utilization and expansion of those pre-processing techniques.
\\ \\This vignette details the workflow of NanoStringNormCNV. Basic steps include loading the data, running quality control metrics, pre-processing the raw data, calling CNVs, and evaluating and visualizing results. Small example datasets are provided for learning purposes.

<<load.package, results = hide, echo = FALSE >>=
require("NanoStringNormCNV");
@

%------------------------------------------------------------
\section{Setting Up Data}\label{sec:setup}
%------------------------------------------------------------

Raw NanoString data is often provided in RCC files. These files can be imported using \Rfunction{NanoStringNorm::read.markup.RCC} or \Rfunction{NanoStringNorm::read.xls.RCC}. 
\\ \\
Alternatively, data can be read in from a raw text file as a data frame and manually formatted to fit specifications for NanoStringNormCNV usage. The user must ensure that the first three columns of the data frame are 'CodeClass' (probe type), 'Name' (unique probe name), and 'Accession' (name of corresponding gene or genomic segment). The following columns must hold raw sample counts with sample IDs for column names. An example dataset for NanoString raw counts is provided here.

<<eg.load.raw.data>>=
require('NanoStringNormCNV');

# load raw count example dataset
data("NanoString");
print(NanoString[1:6, 1:6]);
@

The sample annotation file (csv or tab-delimited) is loaded separately. It is recommended to use \Rfunction{load.phenodata} as this function checks that the information and formatting meets package requirements for downstream processing. See "PhenoData" man page for details on formatting requirements.

<<eg.load.annotation>>=
# load annotation example dataset
data("PhenoData");

# optionally, read in annotation file (same information as above) 
PhenoData <- load.phenodata(
	fname = system.file("extdata", "PhenoData.tsv", package = "NanoStringNormCNV"),
	separator = "tab"
	);

print(head(PhenoData));
@

%------------------------------------------------------------
\section{Quality Control Metrics}\label{sec:qc}
%------------------------------------------------------------

There are three quality controls metrics available each utilizing one of the three control probe types included in NanoString CNV CodeSets.

\subsection{Positive controls}

Positive control probe counts are correlated with expected concentrations. In accordance with NanoString guidelines, raw counts ($x$) are first converted to target concentrations ($y$) using the following equation:

\[ y = 171.23x + 214.12 \]

Samples with R squared values that fall below 0.95 are flagged. Additionally, diagnostic plots can be generated to visualize results.

<<eg.positive.control.qc, eval = FALSE>>=
# quality control using positive controls
r.squared <- positive.control.qc(raw.data = NanoString);

# plot R squared values
make.positive.control.plot(correlations = r.squared, covs = PhenoData);
@

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.6\textwidth]{positive-control-correlations_zoomed-in.png}  
	\captionof{figure}{R squared values across all samples. All samples are well above the 0.95 cutoff.}
\end{center}

\vspace{5mm}

\subsection{Restriction fragmentation controls}

Restriction fragmentation controls are used to determine whether DNA denaturation and digestion has occured. This metric applies to AluI digested samples. Probes that contain AluI restriction sites (\(A+B)\) are compared to probes that do not (\(C+D\)). Complete denaturation is signified by mean \(C+D\) probe counts of > 200. Complete restriction enzyme digestion is signified by \( C+D/A+B \geq 10 \). Samples with low counts or low ratios are flagged and visualized.

<<eg.restriction.fragmentation.control.qc, eval = FALSE>>=
# checking AluI-digested samples only
excl.samples <- PhenoData$SampleID[PhenoData$Fragmentation != "AluI"];
probe.ratios <- restriction.fragmentation.qc(
	raw.data = NanoString[, ! names(NanoString) %in% excl.samples]
	);
@

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.75\textwidth]{restriction-fragmentation-ratios_multiplot.png}
	\captionof{figure}{Top plot displays restriction fragmentation probe ratios. All sample ratios are well above the minimum of 10 (denoted by the dashed line). The bottom plot displays raw restriction fragmentation probe counts. Yellow bars are not visible indicating that enzyme digestion was successful.}
\end{center}

\vspace{5mm}

\subsection{Invariant controls}

The third quality control step involves plotting invariant control probe counts. Samples found to have mean invariant counts of less than 100 are considered low quality. Low counts in normal reference samples are especially problematic as they lead to exaggerated copy number calls.

<<eg.invariant.control.qc, eval = FALSE>>=
# plotting invariant probes
make.invariant.probe.plot(
	inv.probe.counts = NanoString[NanoString$CodeClass == 'Invariant', -(1:3)],
	tissue.type = PhenoData
	);
@

If there are low count invariant probes, two diagnostic plots are produced. One of these is a barplot showing samples with invariant probe counts of less than 100.

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.6\textwidth]{all-invariant-probe-counts_scatterplot.png}  
	\captionof{figure}{Invariant counts per probe across all samples. Counts that fall under the recommended minimum of 100 are in red.}
\end{center}

\begin{center}
	\includegraphics[width=0.6\textwidth]{low-invariant-probe-counts_barplot.png}  
	\captionof{figure}{The number of probes with low counts per sample. Red bars for normal reference samples and black bars for tumour samples. Low counts are most problematic in reference samples when calling copy number downstream.}
\end{center}

\vspace{5mm}

In this example, samples CPCG0266B.M1 and CPCG0248B.M2 are found to have unusually large numbers of low count probes. As such, here we remove these poor quality reference samples from both the raw count and annotation datasets.

<<eg.remove.low.qual>>=
low.quality <- c('CPCG0266B.M1', 'CPCG0248B.M2');
NanoString  <- NanoString[, !names(NanoString) %in% low.quality];
PhenoData   <- PhenoData[!PhenoData$SampleID %in% low.quality,];
@

It is important to note that the annotation data must be updated to reflect these changes prior to continuing data processing. As CPCG0248B.M2 was the matched normal for tumour sample CPCG0248F1, the reference ID for CPCG0248F1 must be set to 'missing'. Additionally, since both removed samples had replicates, the 'HasReplicate' column must also be updated.    

<<eg.update.data>>==
# update matched normal and replicate information, as necessary
PhenoData[PhenoData$SampleID == 'CPCG0248F1',]$ReferenceID <- 'missing';
PhenoData[PhenoData$SampleID %in% c('CPCG0266B.M2', 'CPCG0248B.M1'),]$HasReplicate <- 0;
@

%------------------------------------------------------------
\section{Normalization Methods}\label{sec:normalization}
%------------------------------------------------------------

Most of the normalization options available in NanoStringNormCNV are accessed through NanoStringNorm. The options are briefly outlined below but for full details please see the NanoStringNorm vignette 'Introduction to analyzing NanoString nCounter data using the NanoStringNorm package'. 
\\ \\
The first option is code count correction ('cc'). Positive controls (PC) are used to minimize any lane-to-lane variation. A normalization factor (NF) is calculated from the PC counts by summarizing the counts using summation ('sum') or by taking the geometric mean ('geo.mean'). All raw counts are then multiplied by the NF. To skip this step, specify 'none'.

Code count correction using summation for probe summarization:

\[ PC_s = \sum_{g=1}^{n_G} PC_{g,s} \]
\[ NF_s = \frac{ \frac{1}{n_S} \times \sum_{s=1}^{n_S} PC_s }{ PC_s } \]
\[ x_{adj} = x_{unadj} \times NF_s \]

Where x = data matrix[g,s], s = sample index, g = gene index, $n_S$ = number of samples and $n_G$ = number of genes.
\\ \\
The second option is background correction ('bc'). Negative controls (NC) are used to account for non-specific binding to probes. To calculate background noise, NC are summarized either by taking the mean ('mean'), the maximum ('max'), or the mean plus two standard deviations ('mean.2sd'). The background is then substracted from each sample. To skip, specify 'none'.

Background correction using mean plus 2 standard deviations for probe summarization:

\[ \mu_{NC_s} = \frac{1}{n_G} \times \sum_{g=1}^{n_G} NC_{g,s} \]
\[ \sigma_{NC_s} = \sqrt{ \frac{1}{n_G} \times \sum_{g=1}^{n_G} (x_{g,s} - \mu_{NC_s})^2 } \]
\[ NC_s = \mu_{NC_s} + 2 \times \sigma_{NC_s} \]
\[ x_{adj} = x_{unadj} \times NC_s \]

Where $\mu$ = mean, $\sigma$ = standard deviation, x = data matrix[g,s], s = sample index, g = gene index, $n_S$ = number of samples and $n_G$ = number of genes.
\\ \\
The third option is sample content correction ('sc'). Housekeeping genes (HK) are used to normalize for genomic DNA input amounts (e.g. differences due to pipetting fluctuations). NanoStringNorm requires probes of code class 'Housekeeping' to perform this step and will throw out an error if they are not provided. To normalize, HK counts are summarized to calculate a normalization factor (NF) by which all counts are multiplied. A number of options are available for probe summarization: 'housekeeping.geo.mean', 'total.sum', 'top.geo.mean', 'low.cv.geo.mean'. To skip, specify 'none'.

Sample content correction using geometric mean for probe summarization:

\[ HK_s = \left( \sqrt[n_G]{\Pi HK_g} \right)_s \]
\[ NF_s = \frac{\frac{1}{n_S} \times \sum_{s=1}^{n_S} HK_s}{HK_s} \]
\[ x_{adj} = x_{unadj} \times NF_s \]

Where x = data matrix[g,s], s = sample index, g = gene index, $n_S$ = number of samples and $n_G$ = number of genes.
\\ \\
Please note that in the dataset we provide, housekeeping genes are either a) 'Endogenous' probes that were found to show little variability in counts across data or b) simulated counts created by adding noise to existing housekeeping genes (these can be identified by their name prefix 'SIM'). Code class of these genes must be set to 'Housekeeping'.
\\ \\
A new option for sample content correction (not implemented in NanoStringNorm) is invariant probe normalization. This can be run directly with \Rfunction{invariant.probe.norm} or in combination with the other techniques listed here. This is the method outlined in NanoString guidelines for CNV analysis and, therefore, recommended here for sample content correction. Please see function documentation for more information.
\\ \\
The final option is for additional normalization methods, alternative to those proposed by NanoString, including 'vsn', 'rank.normal', and 'quantile'. To skip, specify 'none'.
\\ \\
Finally, to maximize flexbility, cartridges can either be processed independently or combined (recommended). Two wrapper functions are provided for these purposes: \Rfunction{normalize.global} and \Rfunction{normalize.per.chip}.

<<eg.norm1>>=
# example 1
# perform invariant probe normalization only --cartridges combined
NanoString.norm <- normalize.global(
	raw.data = NanoString,
	cc = 'none',
	bc = 'none',
	sc = 'none',
	oth = 'none',
	do.rcc.inv = TRUE,
	covs = NA,
	phenodata = PhenoData
	);
@

<<eg.norm2>>=
# example 2
# perform invariant probe normalization only --cartridges individually
NanoString.norm <- normalize.per.chip(
	raw.data = NanoString,
	cc = 'none',
	bc = 'none',
	sc = 'none',
	oth = 'none',
	do.rcc.inv = TRUE,
	covs = NA,
	phenodata = PhenoData
	);
@

<<eg.norm3>>=
# example 3
# include covariates for sample cartridge and sample type 
# covariates must be binary as they are passed directly to NanoStringNorm 'traits'
covs <- as.data.frame(matrix(
	1,
	nrow = nrow(PhenoData),
	ncol = length(unique(PhenoData$Cartridge)),
	dimnames = list(
		PhenoData$SampleID,
		paste0("Cartridge", unique(PhenoData$Cartridge))
		)
	));

for (n in 1:nrow(PhenoData)) {
	covs[n, which(unique(PhenoData$Cartridge) == PhenoData$Cartridge[n])] <- 2;
	}

covs$Type <- ifelse(PhenoData$Type == 'Reference', 1, 2);

NanoString.norm <- normalize.global(
	raw.data = NanoString,
	cc = 'none',
	bc = 'none',
	sc = 'none',
	oth = 'none',
	do.rcc.inv = TRUE,
	covs = covs,
	phenodata = PhenoData
	);
@

<<eg.norm4>>=
# same as above but per chip
NanoString.norm <- normalize.per.chip(
	raw.data = NanoString,
	cc = 'none',
	bc = 'none',
	sc = 'none',
	oth = 'none',
	do.rcc.inv = TRUE,
	covs = covs,
	phenodata = PhenoData
	);
@

Post-normalization, for datasets where there are multiple probes per gene/genome segment, one may choose to collapse probes to a single value. Probes with matching 'Accession' values are collapsed by taking their mean count. Unique probe 'Name' values are substituted with 'Accession' values.

<<eg.collapse.genes>>=
NanoString.norm.col <- collapse.genes(normalized.data = NanoString.norm);
print(NanoString.norm.col[1:6, 1:6]);
@

%------------------------------------------------------------
\section{Calling CNAs}\label{sec:cnas}
%------------------------------------------------------------

Two functions are provided to perform CNA calling on normalized data: \Rfunction{call.cnas.with.matched.normals} and \Rfunction{call.cnas.with.pooled.normals}. To call copy number using pooled normals, normal counts are summarized per probe by taking the mean of the samples.
\\ \\
Calling can be performed on sex chromosome segments provided that sample sex information is provided in sample annotation.
\\ \\
For each probe ('Endogenous', 'Invariant', 'Housekeeping'), tumour:normal ratios are calculated. If calling using matched normals, each tumour sample probe is divided by its corresponding matched normal probe. 

\[ ratio_{x} = \frac{normalized\,count_{tumour_x}}{normalized\,count_{normal_x}} \]

If calling using pooled normals, each tumour sample probe is divided by the normal cohort's mean count of the corresponding probe. 

\[ ratio_{x} = \frac{normalized\,count_{tumour_x}}{normalized\,count_{normal_{mean(1...n)}}} \]

Additionally for pooled normals, ratios for normal sample probes are also calculated. 

\[ ratio_{x} = \frac{normalized\,count_{normal_x}}{normalized\,count_{normal_{mean(1...n)}}} \]

% \\ \\
As suggested by NanoString guidelines, tumour:normal ratios are then boosted by a multiplication factor. For autosomal chromosome probe ratios, this is a multiplication factor of two, representing the diploid nature of the genome. This is also true for chromosome X probes in female samples. For sex chromosome probes in male samples, a multiplication factor of one is used instead.

\[ ratio_{x} = ratio_{x} \times multiplication\,factor \]

Furthermore, when calling copy number with pooled normals, ratios are additionally adjusted so that median sample copy number is equal to the multiplication factor. For a given sample,

\[ ratio_{1...n} = ratio_{1...n} - (\,median(ratio_{1...n}) - multiplication factor\,) \]

Next, ratios are converted to categorical CNA calls (0 to 4) by rounding. Rounding is performed using four thresholds representing 1) a homozygous deletion, 2) a heterozygous deletion, 3) a single-copy gain and 4) a multi-copy gain.
% \\ \\
% \indent \indent \indent \(\textrm{if} \quad ratio_x \leq threshold_1 \quad \textrm{then} \quad cna_x = 0 \)\\
% \indent \indent \indent \(\textrm{if} \quad ratio_x > threshold_1 \quad \textrm{and} \quad ratio_x \leq threshold_2 \quad \textrm{then} \quad cna_x = 1 \)\\
% \indent \indent \indent \(\textrm{if} \quad ratio_x > threshold_2 \quad \textrm{and} \quad ratio_x \leq threshold_3 \quad \textrm{then} \quad cna_x = 2 \)\\
% \indent \indent \indent \(\textrm{if} \quad ratio_x > threshold_3 \quad \textrm{and} \quad ratio_x \leq threshold_4 \quad \textrm{then} \quad cna_x = 3 \)\\
% \indent \indent \indent \(\textrm{if} \quad ratio_x > threshold_4 \quad \textrm{then} \quad cna_x = 4 \)\\

Currently, there are three options available for setting the CNA thresholds:

\begin{enumerate}
\item{Derived from NanoString manual recommendations. Thresholds are: 0.4, 1.5, 2.5, 3.5}
\item{Calculated from normal sample cohort ratios (as such, this option is only available for \Rfunction{call.cnas.pooled.normals}). Sex chromosome probe information from male samples is excluded from the following calculations. The minimum and maximum ratios are obtained from each normal sample and the median minimum (min) and maximum (max) ratios are selected. Using all normal sample ratios, standard deviation (SD) is calculated. Thresholds are: min, min + SD, max - SD, max}
\item{By applying the kernel-density approach. Kernel density estimates are calculated from the tumour:normal ratio distribution by translating user-supplied percentages to thresholds. While we provide default values as an example (0.85, 0.95; interpreted as 0.95, 0.85, 0.85, 0.95), the user is highly encouraged to identify cutpoints applicable to their dataset. Note that these are sample-specific if using \Rfunction{call.cnas.with.matched.normals} and cohort-specific if using \Rfunction{call.cnas.with.pooled.normals}.}
\end{enumerate}

<<call.cnas.matched.ref>>=
# Option 1: call using matched normal reference
cnas <- call.cnas.with.matched.normals(
	normalized.data = NanoString.norm,
	phenodata = PhenoData,
	per.chip = FALSE,
	call.method = 2,
	kd.values = c(0.99, 0.87, 0.89, 0.96),
	use.sex.info = TRUE
	);
@

<<call.cnas.pooled.ref>>=
# Option 2: call using a pooled normals reference
cnas <- call.cnas.with.pooled.normals(
	normalized.data = NanoString.norm,
	phenodata = PhenoData,
	per.chip = FALSE,
	call.method = 3,
	use.sex.info = TRUE
	);
# Option 3: call using a pooled normals reference
cnas <- call.cnas.with.pooled.normals(
	normalized.data = NanoString.norm,
	phenodata = PhenoData,
	per.chip = FALSE,
	call.method = 1,
	use.sex.info = TRUE
	);
@

%------------------------------------------------------------
\section{Evaluating Results}\label{sec:eval}
%------------------------------------------------------------
To determine the optimal schema for one's dataset, it is recommended to run and compare several (if not all) pre-processing parameter combinations. Several functions have been added to facilitate this comparison.
\\ \\
Information from replicate samples can be used to determine the concordance of categorical CNA calls or variance in the continuous tumour-normal ratio space.

<<eg.eval.reps>>=
# if technical replicates are available
evaluation <- evaluate.replicates(
	phenodata = PhenoData,
	normalized.data = NanoString.norm,
	cna.rounded = cnas$rounded
	);
@

Another option is to calculate adjusted Rand indexes (ARI) which measure to what extent data clusters according to some feature (e.g. tissue type). This can be performed on either continuous (i.e. normalized counts) or discrete data (i.e. copy number calls).

<<eg.ari1>>=
# how well does the data cluster around the patients from which samples were obtained
patient.ari <- get.ari(
	data.to.cluster = evaluation$cna.calls,
	feature = PhenoData[match(colnames(evaluation$cna.calls), PhenoData$SampleID),]$Patient,
	is.discrete = TRUE
	);
@

<<eg.ari2>>=
# how much does the data cluster around the cartridges on which the samples were processed
# log values, if appropriate
if (all(unlist(NanoString.norm) >= 0)) {
    count.data <- log10(NanoString.norm[, -c(1:3)] + 1);
} else {
    count.data <- NanoString.norm[, -c(1:3)];
    }

cartridge.ari <- get.ari(
    data.to.cluster = count.data,
    feature = PhenoData$Cartridge[match(colnames(NanoString.norm[, -(1:3)]), PhenoData$SampleID)],
    is.discrete = FALSE
    );
@

%------------------------------------------------------------
\section{Visualization}\label{sec:vis}
%------------------------------------------------------------

A number of plotting functions are provided. Diagnostic plots have been described previously (see section 'Quality Control Metrics'). Normalized and copy number data can also be visualized. The plotting wrapper function \Rfunction{visualize.results} will create figures using all available plotting functions.

<<eg.vis1, eval = FALSE>>=
# plot normalized NanoString counts
make.counts.heatmap(
	nano.counts = NanoString.norm[, -(1:3)],
	fname.stem = 'normalized',
	covs.rows = PhenoData[, c('SampleID', 'Type', 'Cartridge')],
	covs.cols = NanoString[, c('Name', 'CodeClass')]
	);

# plot raw NanoString counts
# make sure raw count data frame has gene names for rownames!
NanoString.formatted <- NanoString[, -(1:3)];
rownames(NanoString.formatted) <- NanoString$Name;

make.counts.heatmap(
	nano.counts = NanoString.formatted,
	fname.stem = 'raw',
	covs.rows = PhenoData[, c('SampleID', 'Type', 'Cartridge')],
	covs.cols = NanoString[, c('Name', 'CodeClass')]
	);
@

<<eg.vis2, eval = FALSE>>=
# plot rounded copy number calls
make.cna.heatmap(
	nano.cnas = cnas$rounded,
	fname.stem = 'round',
	covs.rows = PhenoData[, c('SampleID', 'Type', 'Cartridge')],
	covs.cols = NanoString[, c('Name', 'CodeClass')],
	rounded = TRUE
	);

# plot raw (not rounded) copy number calls
make.cna.heatmap(
	nano.cnas = cnas$raw,
	fname.stem = 'raw',
	covs.rows = PhenoData[, c('SampleID', 'Type', 'Cartridge')],
	covs.cols = NanoString[, c('Name', 'CodeClass')],
	rounded = FALSE
	);
@

<<eg.vis3, eval = FALSE>>=
# plot copy number call density for rounded values
# two plots: per gene and per sample
make.cna.densities.plots(
	nano.cnas = cnas$rounded
	);
@

<<eg.vis4, eval = FALSE>>=
# plot raw NanoString count correlations
make.sample.correlations.heatmap(
	nano.counts = NanoString.formatted,
	covs = PhenoData[, c('SampleID', 'Cartridge', 'Type')]
	);
@

<<eg.vis5, eval = FALSE>>=
# plot all results using wrapper function
visualize.results(
    raw.data = NanoString,
    normalized.data = NanoString.norm,
    phenodata = PhenoData,
    cna.rounded = cnas$rounded,
    cna.raw = cnas$raw,
    replicate.eval = evaluation,
    max.cn = 5
    );
@

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{raw-logged_counts-heatmap.png}
	\captionof{figure}{Raw NanoString counts}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{normalized-logged_counts-heatmap.png}
	\captionof{figure}{Normalized NanoString counts}
\end{center}

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{raw-count_inter-sample-correlation-heatmap.png}
	\captionof{figure}{Raw NanoString count inter-sample correlations}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{norm-count_inter-sample-correlation-heatmap.png}
	\captionof{figure}{Normalized NanoString count inter-sample correlations}
\end{center}

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{raw-cna-calls_cna-heatmap.png}
	\captionof{figure}{Raw CNA calls}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{rounded-cna-calls_cna-heatmap.png}
	\captionof{figure}{Rounded CNA calls}
\end{center}

\clearpage

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{raw-cna-calls_gene-densityplot.png}
	\includegraphics[width=0.4\textwidth]{rounded-cna-calls_gene-densityplot.png}
	\caption{Raw (left) and rounded (right) CNA call densities, per gene}
\end{figure}

\vspace{5mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\textwidth]{raw-cna-calls_sample-densityplot.png}
	\includegraphics[width=0.4\textwidth]{rounded-cna-calls_sample-densityplot.png}
	\caption{Raw (left) and rounded (right) CNA call densities, per sample}
\end{figure}

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_raw-logged_counts-heatmap.png}
	\captionof{figure}{Raw counts for replicate samples}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_norm-logged_counts-heatmap.png}
	\captionof{figure}{Normalized counts for replicate samples}
\end{center}

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_norm-count_inter-sample-correlation-heatmap.png}
	\captionof{figure}{Normalized count inter-sample correlations for replicate samples}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_tumour-only_norm-count_inter-sample-correlation-heatmap.png}
	\captionof{figure}{Normalized count inter-sample correlations for replicate samples, tumour only}
\end{center}

\clearpage

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_cna-calls_cna-heatmap.png}
	\captionof{figure}{CNA calls for replicate samples}
\end{center}

\vspace{5mm}

\begin{center}
	\includegraphics[width=0.5\textwidth]{replicate_cna-concordance_counts-heatmap.png}
	\captionof{figure}{Copy number concordance across replicate samples}
\end{center}

%------------------------------------------------------------
\section{References}\label{sec:ref}
%------------------------------------------------------------

\begin{itemize}
	\item{NanoString Technologies, Inc. (2011) nCounter\textregistered: Data Analysis Guidelines for Copy Number Variation (CNV). <https://www.nanostring.com/support/product-support/support-documentation>}
	\item{Waggott, D. et al. (2012) NanoStringNorm: an extensible R package for the pre-processing of NanoString mRNA and miRNA data. Bioinformatics, 28, 1546-1548.}
\end{itemize}

\end{document}
